package main

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/tmc/langchaingo/agents"
	"github.com/tmc/langchaingo/callbacks"
	"github.com/tmc/langchaingo/chains"
	"github.com/tmc/langchaingo/tools"
)

func TestConversationalAgent(t *testing.T) {
	t.Parallel()

	// Create a mock chain and tools
	mockChain := &MockChain{}
	mockTools := []tools.Tool{&MockTool{}}

	// Create a new conversational agent
	agent := agents.NewConversationalAgent(mockChain, mockTools)

	// Test Plan method
	ctx := context.Background()
	intermediateSteps := []schema.AgentStep{}
	inputs := map[string]string{"input": "test input"}

	actions, finish, err := agent.Plan(ctx, intermediateSteps, inputs)
	require.NoError(t, err)
	assert.NotNil(t, actions)
	assert.Nil(t, finish)

	// Test GetInputKeys method
	inputKeys := agent.GetInputKeys()
	assert.Equal(t, []string{"input"}, inputKeys)

	// Test GetOutputKeys method
	outputKeys := agent.GetOutputKeys()
	assert.Equal(t, []string{"output"}, outputKeys)

	// Test GetTools method
	agentTools := agent.GetTools()
	assert.Equal(t, mockTools, agentTools)
}

func TestNewConversationalAgent(t *testing.T) {
	t.Parallel()

	// Create a mock chain and tools
	mockChain := &MockChain{}
	mockTools := []tools.Tool{&MockTool{}}

	// Create a new conversational agent
	agent := agents.NewConversationalAgent(mockChain, mockTools)

	// Test if the agent is initialized correctly
	assert.NotNil(t, agent)
	assert.Equal(t, mockChain, agent.Chain)
	assert.Equal(t, mockTools, agent.Tools)
	assert.Equal(t, "output", agent.OutputKey)
	assert.Nil(t, agent.CallbacksHandler)
}

func TestAgentFinalStreamHandler(t *testing.T) {
	t.Parallel()

	handler := callbacks.NewFinalStreamHandler("Final Answer:")

	// Test GetEgress method
	egress := handler.GetEgress()
	assert.NotNil(t, egress)

	// Test HandleStreamingFunc method
	ctx := context.Background()
	chunk := []byte(" some other text above.\nFinal Answer: This is a correct final string.")
	handler.HandleStreamingFunc(ctx, chunk)

	// Read from egress channel
	result := <-egress
	assert.Equal(t, "This is a correct final string.", string(result))
}

func TestCombiningHandler(t *testing.T) {
	t.Parallel()

	handler1 := &MockHandler{}
	handler2 := &MockHandler{}
	combiningHandler := callbacks.CombiningHandler{
		Callbacks: []callbacks.Handler{handler1, handler2},
	}

	// Test HandleText method
	ctx := context.Background()
	text := "test text"
	combiningHandler.HandleText(ctx, text)

	assert.Equal(t, text, handler1.Text)
	assert.Equal(t, text, handler2.Text)
}

func TestCallFunction(t *testing.T) {
	t.Parallel()

	// Create a mock chain
	mockChain := &MockChain{}

	// Test Call function
	ctx := context.Background()
	inputValues := map[string]any{"input": "test input"}

	outputValues, err := chains.Call(ctx, mockChain, inputValues)
	require.NoError(t, err)
	assert.NotNil(t, outputValues)
}

func TestRunFunction(t *testing.T) {
	t.Parallel()

	// Create a mock chain
	mockChain := &MockChain{}

	// Test Run function
	ctx := context.Background()
	input := "test input"

	output, err := chains.Run(ctx, mockChain, input)
	require.NoError(t, err)
	assert.NotNil(t, output)
}

func TestCalculatorTool(t *testing.T) {
	t.Parallel()

	calculator := tools.NewCalculator()

	// Test basic operations
	result, err := calculator.Calculate("2 + 2")
	require.NoError(t, err)
	assert.Equal(t, 4, result)

	result, err = calculator.Calculate("5 * 3")
	require.NoError(t, err)
	assert.Equal(t, 15, result)
}

func TestDuckDuckGoTool(t *testing.T) {
	t.Parallel()

	duckDuckGo := tools.NewDuckDuckGo()

	// Test search functionality
	results, err := duckDuckGo.Search("test query")
	require.NoError(t, err)
	assert.NotNil(t, results)
}

func TestConversationBuffer(t *testing.T) {
	t.Parallel()

	buffer := memory.NewConversationBuffer()

	// Test memory functionality
	ctx := context.Background()
	err := buffer.SaveContext(ctx, map[string]any{"foo": "bar"}, map[string]any{"bar": "foo"})
	require.NoError(t, err)

	result, err := buffer.LoadMemoryVariables(ctx, map[string]any{})
	require.NoError(t, err)
	assert.Equal(t, map[string]any{"history": "Human: bar\nAI: foo"}, result)
}

func TestConversationTokenBuffer(t *testing.T) {
	t.Parallel()

	tokenBuffer := memory.NewConversationTokenBuffer(2000)

	// Test token buffer functionality
	ctx := context.Background()
	err := tokenBuffer.SaveContext(ctx, map[string]any{"foo": "bar"}, map[string]any{"bar": "foo"})
	require.NoError(t, err)

	result, err := tokenBuffer.LoadMemoryVariables(ctx, map[string]any{})
	require.NoError(t, err)
	assert.Equal(t, map[string]any{"history": "Human: bar\nAI: foo"}, result)
}

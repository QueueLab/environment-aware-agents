package token_tracking

import (
	"fmt"
	"os"
	"path/filepath"
	"time"
)

type TokenTracker struct {
	RunID       string
	TokenUsage  int
	UnitCost    float64
	LogFilePath string
}

func NewTokenTracker(runID string, unitCost float64) (*TokenTracker, error) {
	tracker := &TokenTracker{
		RunID:    runID,
		UnitCost: unitCost,
	}

	err := tracker.initializeLogFile()
	if err != nil {
		return nil, err
	}

	return tracker, nil
}

func (t *TokenTracker) initializeLogFile() error {
	dir := filepath.Join("token_tracking", t.RunID)
	err := os.MkdirAll(dir, os.ModePerm)
	if err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	t.LogFilePath = filepath.Join(dir, "token_usage.log")
	file, err := os.Create(t.LogFilePath)
	if err != nil {
		return fmt.Errorf("failed to create log file: %w", err)
	}
	defer file.Close()

	return nil
}

func (t *TokenTracker) LogTokenUsage(tokens int) error {
	t.TokenUsage += tokens
	return t.logToFile(fmt.Sprintf("Tokens used: %d", tokens))
}

func (t *TokenTracker) LogCost() error {
	cost := float64(t.TokenUsage) * t.UnitCost
	return t.logToFile(fmt.Sprintf("Total cost: %.2f", cost))
}

func (t *TokenTracker) logToFile(message string) error {
	file, err := os.OpenFile(t.LogFilePath, os.O_APPEND|os.O_WRONLY, os.ModeAppend)
	if err != nil {
		return fmt.Errorf("failed to open log file: %w", err)
	}
	defer file.Close()

	logMessage := fmt.Sprintf("%s: %s\n", time.Now().Format(time.RFC3339), message)
	_, err = file.WriteString(logMessage)
	if err != nil {
		return fmt.Errorf("failed to write to log file: %w", err)
	}

	return nil
}
